pragma solidity ^0.4.18;

import "./zeppelin/math/SafeMath.sol";
import "./zeppelin/ownership/Ownable.sol";
import "./zeppelin/token/ERC20/ERC20.sol";
import "./zeppelin/token/MintableToken.sol";
import "./minime/MiniMeToken.sol";
import "./interfaces/POSControllerI.sol";
import "./interfaces/ERC165.sol";


/// @title POSController
/// @dev POSController contract is a minime token controller that generate token interests
/// according to predefined POSController-like rule.
contract POSController is Ownable, POSControllerI {
    using SafeMath for uint;

    struct Claim {
        uint128 fromBlock;
        uint128 claimedValue;
    }

    address public token;

    // POSController parameters
    uint public posInterval;
    uint public posRate;
    uint public posCoeff;

    uint public initBlockNumber;

    mapping (address => Claim[]) public claims;

    /* Constructor */
    function POSController(
        address _token,
        uint _posInterval,
        uint _initBlockNumber,
        uint _posRate,
        uint _posCoeff
    ) public {
        require(_token != address(0));

        token = _token;
        posInterval = _posInterval;
        posRate = _posRate;
        posCoeff = _posCoeff;

        if (_initBlockNumber == 0) {
            initBlockNumber = block.number;
        } else {
            initBlockNumber = _initBlockNumber;
        }
    }

    /* External */
    function setRate(uint _newRate) external onlyOwner {
        require(_newRate != 0);
        posRate = _newRate;
    }

    function setInterval(uint _newInterval) external onlyOwner {
        require(_newInterval != 0);
        posInterval = _newInterval;
    }

    /* Public */
    /// @notice claim interests generated by POSController
    function claimTokens(address _owner) public {
        doClaim(_owner, claims[_owner]);
    }

    /* Internal */
    function doClaim(address _owner, Claim[] storage c) internal {
        uint claimRate;

        if (c.length == 0 && claimable(block.number)) {
            claimRate = getClaimRate(0);
        } else if (c.length > 0 && claimable(c[c.length - 1].fromBlock)) {
            claimRate = getClaimRate(c[c.length - 1].fromBlock);
        }

        if (claimRate > 0) {
            Claim storage newClaim = c[c.length++];

            // TODO: reduce variables into few statements
            uint balance = ERC20(token).balanceOf(_owner);

            uint targetBalance = balance.mul(posCoeff.add(claimRate)).div(posCoeff);
            uint claimedValue = targetBalance.sub(balance);

            newClaim.claimedValue = uint128(claimedValue);
            newClaim.fromBlock = uint128(block.number);

            require(generateTokens(_owner, newClaim.claimedValue));
        }
    }

    function generateTokens(address _to, uint256 _value) internal returns (bool) {
        if (ERC165(token).supportsInterface(bytes4(keccak256("mint(address,uint256)")))) {
            return MintableToken(token).mint(_to, _value);
        } else if (ERC165(token).supportsInterface(bytes4(keccak256("generateTokens(address,uint256)")))) {
            return MiniMeToken(token).generateTokens(_to, _value);
        }

        return false;
    }

    function claimable(uint _blockNumber) internal view returns (bool) {
        if (_blockNumber < initBlockNumber) return false;

        return (_blockNumber - initBlockNumber) >= posInterval;
    }

    function getClaimRate(uint _fromBlock) internal view returns (uint) {
        // interval block number when token holder get interests.
        // if holder didn't claim before, `initBlockNumber`
        // otherwise, n-th interval block (`initBlockNumber` + k * `posInterval`)
        uint lastIntervalBlock;

        if (_fromBlock == 0) { // first claim
            lastIntervalBlock = initBlockNumber;
        } else { // second or further claim
            // TODO:
            uint offset = _fromBlock.sub(initBlockNumber) % posInterval;
            lastIntervalBlock = _fromBlock.sub(offset);
        }

        // # of cumulative claims
        uint pow = block.number.sub(lastIntervalBlock) / posInterval;

        // assume 1 claim is given to reduce loop iteration
        uint rate = posRate;

        // if claim rate is 10%,
        // 1st claim: 10%
        // 2nd claim: 10% + 11%
        // 3rd claim: 10% + (10% + 11%) * 110%
        //
        // ith claim: posRate + [i-1th claim] * (posCoeff + posRate) / posCoeff
        for (uint i = 0; i < pow - 1; i++) {
            rate = rate.mul(posCoeff.add(posRate)).div(posCoeff).add(posRate);
        }

        return rate;
    }
}
